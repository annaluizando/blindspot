package ui

import (
	"blindspot/internal/challenges"
	"blindspot/internal/game"

	"golang.org/x/sys/unix"

	tea "github.com/charmbracelet/bubbletea"
)

func InitializeUIWithChallenge(gs *game.GameState) (*tea.Program, error) {
	width, height := getTerminalSize()

	challenge := determineStartingChallenge(gs)

	challengeView := NewChallengeView(gs, challenge, width, height, MainMenu)

	program := tea.NewProgram(
		challengeView,
		tea.WithAltScreen(),
		tea.WithMouseCellMotion(),
	)

	return program, nil
}

func getTerminalSize() (width, height int) {
	width, height = 80, 24

	ws, err := unix.IoctlGetWinsize(unix.Stdin, unix.TIOCGWINSZ)
	if err == nil {
		// Successfully got terminal size
		width = int(ws.Col)
		height = int(ws.Row)

		// Ensure minimum dimensions
		if width < 40 {
			width = 40
		}
		if height < 10 {
			height = 10
		}
	}

	return width, height
}

// selects the appropriate challenge to start with
// may be deleted
func determineStartingChallenge(gs *game.GameState) challenges.Challenge {
	// If we're in randomized mode, use randomized challenges
	if gs.UseRandomizedOrder {
		// Randomized challenges should already be generated by this point
		if len(gs.RandomizedChallenges) > 0 {
			// Ensure indices are within bounds
			if gs.CurrentChallengeIdx >= len(gs.RandomizedChallenges) {
				gs.CurrentChallengeIdx = 0
				gs.Progress.CurrentChallengeIdx = 0
				gs.SaveProgress()
			}
			return gs.RandomizedChallenges[gs.CurrentChallengeIdx]
		}

		// Fallback: if randomized challenges are missing, generate them
		// This shouldn't normally happen, but provides safety
		gs.RandomizedChallenges = gs.GetChallengesGroupedByDifficulty()
		gs.SaveRandomizedOrder()
		gs.CurrentChallengeIdx = 0
		gs.Progress.CurrentChallengeIdx = 0
		gs.SaveProgress()
		return gs.RandomizedChallenges[0]
	}

	// Category-based mode: find the next incomplete challenge
	challenge, found := gs.GetNextIncompleteChallenge()
	if found {
		return challenge
	}

	// No incomplete challenges found, start with the first challenge
	return gs.ChallengeSets[0].Challenges[0]
}
