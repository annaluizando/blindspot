challengeSets:
  - category: "Broken Access Control"
    id: "broken-access-control"
    description: "Access control enforces policies such that users cannot act outside of their intended permissions.\nFailures typically lead to unauthorized disclosure, modification, or destruction of data."
    challenges:
      - id: "broken-access-control-1"
        title: "Insecure Direct Object Reference (IDOR)"
        description: "This API endpoint retrieves documents based on user input. What security vulnerability exists?"
        difficulty: 0 # Beginner
        code: |
          @app.route('/api/documents/<int:doc_id>', methods=['GET'])
          @login_required
          def get_document(doc_id):
              document = Document.query.get_or_404(doc_id)
              return jsonify({
                  'id': document.id,
                  'title': document.title,
                  'content': document.content,
                  'owner_id': document.owner_id
              })
        options:
          - "The endpoint doesn't validate if the user is authorized to access the document"
          - "The endpoint doesn't sanitize the doc_id parameter"
          - "The endpoint doesn't check for CSRF tokens"
          - "The endpoint doesn't use HTTPS"
        correctAnswer: "The endpoint doesn't validate if the user is authorized to access the document"
        hint: "The function retrieves and returns any document without checking if the current user has permission to access it."
        explanation: "The endpoint uses @login_required to ensure the user is authenticated, but it doesn't verify if the authenticated user has permission to access the specific document. An attacker could access any document by simply changing the doc_id parameter, even if they don't own it. This is a classic IDOR (Insecure Direct Object Reference) vulnerability."
        lang: "python"

      - id: "broken-access-control-2"
        title: "Missing Function Level Access Control"
        description: "This router setup configures several admin endpoints. What security issue exists?"
        difficulty: 1 # Intermediate
        code: |
          func SetupAdminRoutes(router *mux.Router) {
              admin := router.PathPrefix("/admin").Subrouter()
              
              admin.HandleFunc("/users", ListAllUsers)
              admin.HandleFunc("/system-config", UpdateSystemConfig)
              admin.HandleFunc("/delete-user/{id}", DeleteUser)
              admin.HandleFunc("/dashboard", ShowAdminDashboard)
          }
        options:
          - "The router doesn't implement logging for admin actions"
          - "The router uses vulnerable route parameter formats"
          - "The router doesn't apply authentication/authorization middleware"
          - "The router isn't using HTTPS for admin endpoints"
        correctAnswer: "The router doesn't apply authentication/authorization middleware"
        hint: "How does the application verify that only administrators can access these endpoints?"
        explanation: "The router sets up admin endpoints but doesn't apply any middleware to verify that the requesting user is actually an administrator. Without authentication and authorization checks, anyone who knows the admin URL paths could potentially access sensitive administrative functions like listing all users, updating system configuration, or deleting user accounts."
        lang: "go"

      - id: "broken-access-control-3"
        title: "Directory Traversal via File Path"
        description: "This function allows users to download files by specifying a filename. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          @GetMapping("/download")
          public ResponseEntity<Resource> downloadFile(@RequestParam String filename) {
              try {
                  Path filePath = Paths.get("/var/uploads/" + filename);
                  Resource resource = new UrlResource(filePath.toUri());
                  
                  if (resource.exists()) {
                      return ResponseEntity.ok()
                          .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
                          .body(resource);
                  }
              } catch (Exception e) {
                  # Error handling
              }
              return ResponseEntity.notFound().build();
          }
        options:
          - "The function doesn't validate file extensions"
          - "The function is vulnerable to directory traversal attacks"
          - "The function doesn't check file permissions"
          - "The function doesn't sanitize the filename parameter"
        correctAnswer: "The function is vulnerable to directory traversal attacks"
        hint: "What happens if filename contains '../' sequences?"
        explanation: "The function concatenates the user-provided filename directly to the base path without validation. An attacker can use '../' sequences to navigate outside the intended directory. For example, a filename like '../../../etc/passwd' would allow access to system files outside the uploads directory, potentially exposing sensitive information or allowing unauthorized file access."
        lang: "java"

  - category: "Cryptographic Failures"
    id: "cryptographic-failures"
    description: "Failures related to cryptography that often lead to sensitive data exposure or system compromise."
    challenges:
      - id: "crypto-1"
        title: "Insecure Password Storage"
        description: "This function handles user registration and password storage. What security issue exists?"
        difficulty: 0 # Beginner
        code: |
          function registerUser(username, password) {
              const hashedPassword = crypto.createHash('md5').update(password).digest('hex');
              
              const user = new User({
                  username: username,
                  password: hashedPassword
              });
              
              return user.save();
          }
        options:
          - "The function doesn't validate the password strength"
          - "The function uses MD5, which is not secure for password hashing"
          - "The function doesn't sanitize the username parameter"
          - "The database query is vulnerable to injection"
        correctAnswer: "The function uses MD5, which is not secure for password hashing"
        hint: "Look at the algorithm used for storing passwords. Is it suitable for this purpose?"
        explanation: "MD5 is a cryptographic hash function that is cryptographically broken and unsuitable for password hashing. It's vulnerable to collision attacks and rainbow table attacks. Additionally, MD5 is extremely fast, making brute force attacks much more feasible. Modern applications should use dedicated password hashing algorithms like bcrypt, Argon2, or PBKDF2 which are designed to be slow and include salt."
        lang: "javascript"

      - id: "crypto-2"
        title: "Hardcoded Encryption Key"
        description: "This function encrypts data using AES. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          def encrypt_data(data):
              key = b"SuperS3cretKey12345"
              
              cipher = AES.new(key, AES.MODE_CBC)
              ct_bytes = cipher.encrypt(pad(data, AES.block_size))
              
              return cipher.iv + ct_bytes
        options:
          - "The function isn't using authenticated encryption"
          - "The initialization vector (IV) is predictable"
          - "The encryption key is hardcoded in the source code"
          - "The AES cipher is used in an insecure mode"
        correctAnswer: "The encryption key is hardcoded in the source code"
        hint: "Where is the encryption key stored and how is it managed?"
        explanation: "The encryption key is hardcoded directly in the source code, which is a serious security risk. If the source code is ever exposed (through version control, deployment, or reverse engineering), the encryption key becomes known to attackers. Additionally, the same key is used for all encryption operations, meaning if one encrypted value is compromised, all others encrypted with the same key are potentially at risk."
        lang: "python"

      - id: "crypto-3"
        title: "Weak Random Number Generation"
        description: "This function generates session tokens for user authentication. What security issue exists?"
        difficulty: 1 # Intermediate
        code: |
          function generateSessionToken() {
              const randomBytes = [];
              for (let i = 0; i < 32; i++) {
                  randomBytes.push(Math.floor(Math.random() * 256));
              }
              return Buffer.from(randomBytes).toString('hex');
          }
        options:
          - "The function generates tokens that are too short"
          - "The function uses Math.random() which is not cryptographically secure"
          - "The function doesn't check for token collisions"
          - "The function doesn't include timestamp information"
        correctAnswer: "The function uses Math.random() which is not cryptographically secure"
        hint: "Math.random() is not suitable for security purposes. What should be used instead?"
        explanation: "Math.random() is a pseudo-random number generator that is not cryptographically secure. It's designed for statistical randomness, not security. Attackers could potentially predict the generated values, making session tokens predictable and vulnerable to session hijacking. For security-critical applications, use crypto.randomBytes() or crypto.getRandomValues() which provide cryptographically secure random numbers."
        lang: "javascript"

  - category: "Injection"
    id: "injection"
    description: "Injection flaws occur when untrusted data is sent to an interpreter as part of a command or query."
    challenges:
      - id: "sql-injection-basic"
        title: "Basic SQL Injection"
        description: "This function retrieves a user's profile from the database. What security vulnerability exists?"
        difficulty: 0 # Beginner
        code: |
          function getUserProfile($username) {
              global $connection;

              $query = "SELECT * FROM users WHERE username = '" . $username . "'";
              $result = mysqli_query($connection, $query);

              return mysqli_fetch_assoc($result);
          }
        options:
          - "The function doesn't escape special characters in the input"
          - "The function does not validate the username format"
          - "The function might return a null value if the user does not exist"
          - "The database query is inefficient"
        correctAnswer: "The function doesn't escape special characters in the input"
        hint: "Look at how the query string is constructed. What happens if the username contains SQL syntax?"
        explanation: "The function concatenates user input directly into the SQL query string without proper escaping or parameterization. An attacker can inject malicious SQL code through the username. For example, using username ' OR 1=1--' would result in the query 'SELECT * FROM users WHERE username = '' OR 1=1--'', which could return all users in the database."
        lang: "php"

      - id: "sql-injection-2"
        title: "SQL Injection in a Web Handler"
        description: "This HTTP handler retrieves user profile information from a database. What security issue exists?"
        difficulty: 1 # Intermediate
        code: |
          func handleUserProfile(w http.ResponseWriter, r *http.Request) {
              userID := r.URL.Query().Get("id")
              
              db, _ := sql.Open("mysql", "user:password@/dbname")
              defer db.Close()
              
              query := fmt.Sprintf("SELECT username, email FROM users WHERE id = %s", userID)
              rows, _ := db.Query(query)
              defer rows.Close()
              
              var username, email string
              if rows.Next() {
                  rows.Scan(&username, &email)
                  fmt.Fprintf(w, "User: %s, Email: %s", username, email)
              }
          }
        options:
          - "The handler doesn't check for errors from database operations"
          - "The handler doesn't sanitize user input and is vulnerable to SQL injection"
          - "The handler hard-codes database credentials in code"
          - "The handler sends sensitive information without encryption"
        correctAnswer: "The handler doesn't sanitize user input and is vulnerable to SQL injection"
        hint: "Notice how the userID parameter is included in the SQL query."
        explanation: "The handler uses fmt.Sprintf to directly interpolate the userID parameter into the SQL query string. This allows attackers to inject malicious SQL code. For instance, if userID is '1; DROP TABLE users; --', the resulting query would be 'SELECT username, email FROM users WHERE id = 1; DROP TABLE users; --', potentially destroying the users table."
        lang: "go"

      - id: "command-injection-1"
        title: "Command Injection in Exec"
        description: "This function executes a system command to check server connectivity. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          def ping_server(server_address):
              import subprocess
              
              command = f"ping -c 3 {server_address}"
              result = subprocess.run(command, shell=True, capture_output=True, text=True)
              
              return result.stdout
        options:
          - "The function is vulnerable to command injection"
          - "The function doesn't validate the server address format"
          - "The ping command shouldn't be used in production code"
          - "The output isn't properly sanitized before returning"
        correctAnswer: "The function is vulnerable to command injection"
        hint: "Think about what happens if server_address contains special shell characters."
        explanation: "The function uses shell=True with subprocess.run(), which means the command is executed through the shell. If an attacker can control the server_address parameter, they can inject shell commands like '; rm -rf /' or '&& cat /etc/passwd'. The shell=True flag makes the function vulnerable to command injection attacks."
        lang: "python"

      - id: "nosql-injection-1"
        title: "NoSQL Injection in MongoDB"
        description: "This endpoint authenticates users against a MongoDB database. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          app.post('/api/login', (req, res) => {
              const { username, password } = req.body;
              
              const user = await User.findOne({
                  username: username,
                  password: password
              });
              
              if (user) {
                  res.json({ success: true, user: user });
              } else {
                  res.status(401).json({ success: false });
              }
          });
        options:
          - "The function doesn't validate input types"
          - "The function is vulnerable to NoSQL injection attacks"
          - "The function doesn't hash passwords"
          - "The function doesn't implement rate limiting"
        correctAnswer: "The function is vulnerable to NoSQL injection attacks"
        hint: 'What happens if an attacker sends an object like {username: {$ne: ""}}?'
        explanation: 'The function directly passes user input to MongoDB queries without validation. An attacker can send malicious objects like {username: {$ne: ""}} which would match any username that is not empty, potentially bypassing authentication. The $ne operator is a MongoDB query operator that means ''not equal'', allowing attackers to manipulate query logic.'
        lang: "javascript"

  - category: "Insecure Design"
    id: "insecure-design"
    description: "Insecure design refers to flaws in application design and architecture rather than implementation bugs."
    challenges:
      - id: "insecure-design-1"
        title: "Insecure Password Reset"
        description: "This function sends a new password to the user's email. What is the primary security flaw in this approach?"
        difficulty: 2 # Advanced
        code: |
          import (
              "math/rand"
              "time"
          )

          func init() {
              rand.Seed(time.Now().UnixNano())
          }

          func PasswordRecovery(w http.ResponseWriter, r *http.Request) {
              if r.Method != "POST" {
                  renderPasswordRecoveryForm(w)
                  return
              }
              
              email := r.FormValue("email")
              
              user, err := db.FindUserByEmail(email)
              if err != nil {
                  http.Error(w, "User not found", http.StatusNotFound)
                  return
              }
              
              securityQuestion := user.SecurityQuestion
              userAnswer := r.FormValue("answer")
              
              if userAnswer == user.SecurityAnswer {
                  newPassword := generateRandomPassword()
                  user.SetPassword(newPassword)
                  user.Save()
                  
                  sendPasswordEmail(user.Email, newPassword)
                  
                  http.Redirect(w, r, "/login", http.StatusSeeOther)
              } else {
                  http.Error(w, "Incorrect answer", http.StatusUnauthorized)
              }
          }

          func generateRandomPassword() string {
              var charset = "abcdefghijklmnopqrstuvwxyz0123456789"
              password := make([]byte, 8)
              for i := range password {
                  password[i] = charset[rand.Intn(len(charset))]
              }
              return string(password)
          }
        options:
          - "Sending passwords directly to users via email is insecure."
          - "The generated password is not complex enough."
          - "The security question is not a strong authentication factor."
          - "The function should log the password change for auditing."
        correctAnswer: "Sending passwords directly to users via email is insecure."
        hint: "What is the best practice for handling password resets? Should the system ever handle plaintext passwords?"
        explanation: "The primary design flaw is sending a new password directly to the user's email. Email is not a secure channel; it can be intercepted, and emails are often stored in plaintext. The best practice is to send a secure, time-limited, single-use token or link that allows the user to reset their own password."
        lang: "go"

      - id: "insecure-design-2"
        title: "Race Condition in Account Creation"
        description: "This function creates new user accounts in the system. What security design flaw exists?"
        difficulty: 2 # Advanced
        code: |
          @PostMapping("/api/register")
          public ResponseEntity<?> registerUser(@RequestBody UserRegistrationRequest request) {
              // Check if user exists
              if (userService.userExists(request.getUsername())) {
                  return ResponseEntity.badRequest().body("Username already exists");
              }
              
              User user = new User();
              user.setUsername(request.getUsername());
              user.setPassword(passwordEncoder.encode(request.getPassword()));
              userService.saveUser(user);
              
              return ResponseEntity.ok("User created successfully");
          }
        options:
          - "The function doesn't validate password strength"
          - "The function is vulnerable to race condition attacks"
          - "The function doesn't sanitize input"
          - "The function doesn't implement proper error handling"
        correctAnswer: "The function is vulnerable to race condition attacks"
        hint: "What happens if two requests with the same username arrive simultaneously?"
        explanation: "The function checks if a user exists and then creates the user, but there's a time gap between these operations. If two requests with the same username arrive simultaneously, both might pass the existence check before either user is saved, leading to duplicate accounts. This race condition can be exploited to bypass intended business logic."
        lang: "java"

  - category: "Security Misconfiguration"
    id: "security-misconfiguration"
    description: "Security misconfiguration is commonly a result of insecure default configurations."
    challenges:
      - id: "security-misconfig-1"
        title: "Verbose Error Messages"
        description: "This function attempts to connect to a database. What security issue exists?"
        difficulty: 0 # Beginner
        code: |
          func ConnectToDatabase(w http.ResponseWriter, r *http.Request) {
              dbUser := os.Getenv("DB_USER")
              dbPass := os.Getenv("DB_PASS")
              dbHost := os.Getenv("DB_HOST")
              
              connStr := fmt.Sprintf("postgres://%s:%s@%s/app_database",
                  dbUser, dbPass, dbHost)
              
              db, err := sql.Open("postgres", connStr)
              if err != nil {
                                http.Error(w, "Database connection error: "+err.Error(), http.StatusInternalServerError)
                  return
              }
          }
        options:
          - "The function stores database credentials in environment variables"
          - "The function returns detailed error messages to the client"
          - "The function doesn't use SSL for database connection"
          - "The function doesn't close the database connection"
        correctAnswer: "The function returns detailed error messages to the client"
        hint: "What information might be exposed in the error message that could help an attacker?"
        explanation: "The function returns the actual database error message to the client, which can reveal sensitive information about the database structure, connection details, or internal system information. Attackers can use this information to understand the system architecture and potentially exploit other vulnerabilities. Error messages should be generic and not expose internal system details."
        lang: "go"

      - id: "security-misconfig-2"
        title: "Missing Security Headers"
        description: "This Express.js application sets up basic middleware and routes. What important security configuration is missing?"
        difficulty: 1 # Intermediate
        code: |
          const express = require('express');
          const app = express();

          app.use(express.json());
          app.use(express.urlencoded({ extended: true }));

          // What other middleware should be configured for security?

          app.get('/', (req, res) => {
              res.send('Hello World!');
          });

          app.listen(3000, () => {
              console.log('Server running on port 3000');
          });
        options:
          - "The app does not implement logging for requests."
          - "The app is missing middleware to set important security headers."
          - "The app does not use HTTPS to encrypt traffic."
          - "The app does not validate user input in the routes."
        correctAnswer: "The app is missing middleware to set important security headers."
        hint: "Libraries like 'helmet' can automatically set headers such as Content-Security-Policy and X-Frame-Options. What is the risk of not having these?"
        explanation: "The application is missing essential security middleware, such as 'helmet', which sets crucial HTTP headers that help protect against common attacks like Cross-Site Scripting (XSS), clickjacking, and other code injection vulnerabilities. Headers like X-Content-Type-Options, Strict-Transport-Security, and Content-Security-Policy are fundamental for securing a web application."
        lang: "javascript"

  - category: "Vulnerable and Outdated Components"
    id: "vulnerable-outdated-components"
    description: "Using components with known vulnerabilities can undermine application defenses and enable various attacks."
    challenges:
      - id: "outdated-components-1"
        title: "Vulnerable Dependencies"
        description: "This package.json file defines the project dependencies. What security issue exists?"
        difficulty: 0 # Beginner
        code: |
          {
            "name": "my-web-app",
            "version": "1.0.0",
            "dependencies": {
              "express": "4.14.0",
              "body-parser": "1.15.2",
              "jquery": "1.12.4",
              "log4js": "0.6.38",
              "mongoose": "4.7.6"
            },
            "scripts": {
              "start": "node app.js"
            }
          }
        options:
          - "The file is using outdated dependencies with known vulnerabilities"
          - "The file is missing important security packages"
          - "The file uses an insecure package manager"
          - "The file doesn't specify exact versions"
        correctAnswer: "The file is using outdated dependencies with known vulnerabilities"
        hint: "Check the version numbers. Many of these packages have had serious vulnerabilities discovered after these versions were released."
        explanation: "The package.json uses outdated versions of dependencies that contain known security vulnerabilities. For example, Express 4.14.0 has multiple CVE vulnerabilities, jQuery 1.12.4 has XSS vulnerabilities, and other packages have similar issues. Using outdated dependencies exposes the application to attacks that have already been patched in newer versions."
        lang: "json"

      - id: "outdated-components-2"
        title: "Vulnerable Docker Base Image"
        description: "This Dockerfile sets up a Node.js application container. What security issue exists?"
        difficulty: 1 # Intermediate
        code: |
          FROM node:8.17.0

          WORKDIR /app

          COPY package*.json ./
          RUN npm install

          COPY . .

          EXPOSE 3000
          CMD ["npm", "start"]
        options:
          - "The base image is outdated and contains known vulnerabilities"
          - "The Dockerfile doesn't specify a user"
          - "The Dockerfile doesn't implement multi-stage builds"
          - "The Dockerfile doesn't use .dockerignore"
        correctAnswer: "The base image is outdated and contains known vulnerabilities"
        hint: "Node.js 8.17.0 reached end-of-life in 2019 and contains multiple security vulnerabilities."
        explanation: "Node.js 8.17.0 reached end-of-life in December 2019 and no longer receives security updates. This version contains multiple known vulnerabilities including CVE-2019-1563, CVE-2019-1567, and others. Using an outdated base image means the container inherits all these vulnerabilities, making the application vulnerable to various attacks."
        lang: "dockerfile"

  - category: "Identification and Authentication Failures"
    id: "identification-and-auth-failures"
    description: "Authentication failures related to user identity, authentication, and session management."
    challenges:
      - id: "auth-1"
        title: "Insecure Session Management"
        description: "This function creates session tokens for authenticated users. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          function createSession(userId) {
              const timestamp = Date.now();
              const token = `${userId}:${timestamp}`;
              
              sessions[token] = {
                  userId: userId,
                  createdAt: timestamp,
                  expiresAt: timestamp + (24 * 60 * 60 * 1000) // 24 hours
              };
              
              return token;
          }
        options:
          - "The session token is predictable and can be guessed"
          - "The session token format is too simple"
          - "The sessions object could have memory leaks"
          - "The function doesn't check if the user exists"
        correctAnswer: "The session token is predictable and can be guessed"
        hint: "How is the session token generated? Is there any randomness?"
        explanation: "The session token is constructed as 'userId:timestamp', which is completely predictable. An attacker who knows a user's ID can easily guess their session token by using the current timestamp or common timestamp patterns. This makes session hijacking trivial, as attackers can forge valid session tokens without needing to steal them."
        lang: "javascript"

      - id: "auth-2"
        title: "Weak Password Policy"
        description: "This function validates a new password. What is the most significant weakness in this policy?"
        difficulty: 1 # Intermediate
        code: |
          def validate_password(password):
              # The password must be at least 8 characters long
              if len(password) < 8:
                  return False
              
              # The password must not be in a list of common passwords
              if is_common_password(password):
                  return False
                  
              return True
        options:
          - "The policy does not enforce any character complexity requirements."
          - "The minimum password length should be 12 characters."
          - "The function should return a specific error message."
          - "The function should check for keyboard patterns (e.g., 'qwerty')."
        correctAnswer: "The policy does not enforce any character complexity requirements."
        hint: "What is missing from this policy to prevent simple, easily guessable passwords?"
        explanation: "The most significant weakness is the lack of character complexity requirements. A user could choose a password like 'password' or '12345678' which, while meeting the length requirement and not being on a common password list, is still very weak. A strong password policy should enforce a mix of uppercase letters, lowercase letters, numbers, and special characters."
        lang: "python"

      - id: "auth-3"
        title: "Missing Rate Limiting on Login"
        description: "This login endpoint is missing a critical security protection. What is the primary vulnerability?"
        difficulty: 1 # Intermediate
        code: |
          @app.route('/login', methods=['POST'])
          def login():
              username = request.form['username']
              password = request.form['password']
              
              user = User.query.filter_by(username=username).first()
              if user and user.check_password(password):
                  session['user_id'] = user.id
                  return redirect(url_for('dashboard'))
              else:
                  return render_template('login.html', error='Invalid credentials')
        options:
          - "The endpoint is vulnerable to brute-force attacks due to a lack of rate limiting."
          - "The function does not sanitize the username and password inputs."
          - "The error message is too generic and should be more specific."
          - "The session management is not secure."
        correctAnswer: "The endpoint is vulnerable to brute-force attacks due to a lack of rate limiting."
        hint: "What prevents an attacker from trying thousands of passwords for a single user?"
        explanation: "The primary vulnerability is the lack of rate limiting on the login endpoint. This allows an attacker to make an unlimited number of login attempts, making the system highly susceptible to brute-force or credential stuffing attacks. Implementing rate limiting (e.g., a certain number of failed attempts per minute) is a critical defense. While account lockout is another defense, it can be abused by attackers to cause denial-of-service for legitimate users."
        lang: "python"

  - category: "Software and Data Integrity Failures"
    id: "software-and-data-integrity-failures"
    description: "Software and data integrity failures relate to code and infrastructure that does not protect against integrity violations."
    challenges:
      - id: "integrity-1"
        title: "Insecure Deserialization"
        description: "This function loads user preferences from a browser cookie. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          func loadUserPreferences(r *http.Request) map[string]interface{} {
              cookie, err := r.Cookie("user_prefs")
              if err != nil {
                  return map[string]interface{}{}
              }
              
              decoded, err := base64.StdEncoding.DecodeString(cookie.Value)
              if err != nil {
                  return map[string]interface{}{}
              }
              
              var prefs map[string]interface{}
              if err := json.Unmarshal(decoded, &prefs); err != nil {
                  return map[string]interface{}{}
              }
              
              return prefs
          }
        options:
          - "The function doesn't validate the cookie before decoding"
          - "The function uses base64 which isn't encryption"
          - "The function accepts any JSON without verification"
          - "The function doesn't handle errors properly"
        correctAnswer: "The function accepts any JSON without verification"
        hint: "What prevents an attacker from modifying the cookie to inject unexpected values?"
        explanation: "The function deserializes JSON data from cookies without any validation or verification. An attacker can modify the cookie to inject malicious data structures, potentially leading to unexpected behavior or security vulnerabilities. The function should validate the structure and content of the JSON data before processing it."
        lang: "go"

      - id: "integrity-2"
        title: "Insecure File Upload"
        description: "This function allows users to upload files. What is the most critical security vulnerability?"
        difficulty: 2 # Advanced
        code: |
          @PostMapping("/upload-avatar")
          public ResponseEntity<String> uploadAvatar(@RequestParam("file") MultipartFile file) {
              try {
                  String fileName = file.getOriginalFilename();
                  String filePath = "/var/www/html/avatars/" + fileName;
                  
                  File dest = new File(filePath);
                  file.transferTo(dest);
                  
                  return ResponseEntity.ok("File uploaded successfully");
              } catch (Exception e) {
                  return ResponseEntity.status(500).body("Upload failed");
              }
          }
        options:
          - "The function is vulnerable to path traversal attacks."
          - "The function does not validate the file's content type."
          - "The function does not check for file size limits."
          - "The function does not handle potential filename collisions."
        correctAnswer: "The function is vulnerable to path traversal attacks."
        hint: "What would happen if the filename was '../../etc/passwd'?"
        explanation: "The most critical vulnerability is the lack of path traversal protection. The function uses the user-provided filename to construct the destination file path. An attacker could provide a malicious filename like '../../etc/passwd' to overwrite critical system files. While content type validation and size limits are important, path traversal is the most severe risk here."
        lang: "java"

  - category: "Security Logging and Monitoring Failures"
    id: "security-logging-and-monitoring-failures"
    description: "This category helps detect, escalate, and respond to active breaches. Without logging and monitoring, breaches cannot be detected."
    challenges:
      - id: "logging-1"
        title: "Insufficient Logging"
        description: "This function handles user login attempts. What is the primary security logging and monitoring flaw?"
        difficulty: 0 # Beginner
        code: |
          func handleLogin(w http.ResponseWriter, r *http.Request) {
              username := r.FormValue("username")
              password := r.FormValue("password")
              
              user, err := db.GetUserByUsername(username)
              if err != nil {
                  http.Error(w, "Login failed", http.StatusUnauthorized)
                  return
              }
              
              if !user.CheckPassword(password) {
                  http.Error(w, "Login failed", http.StatusUnauthorized)
                  return
              }
              
              session := createSession(user.ID)
              setCookie(w, "session", session)
              http.Redirect(w, r, "/dashboard", http.StatusSeeOther)
          }
        options:
          - "The function does not log failed login attempts."
          - "The function logs the user's password, exposing sensitive data."
          - "The function should log the generated session cookie for tracking."
          - "The function only logs successful logins, not failures."
        correctAnswer: "The function does not log failed login attempts."
        hint: "For security monitoring, which events are more critical to log: successful logins or failed logins?"
        explanation: "The function doesn't log failed login attempts, making it impossible to detect brute force attacks, account takeover attempts, or other suspicious authentication patterns. Without logging, security teams cannot identify compromised accounts or track attack patterns. While logging successes is also important, logging failures is critical for detecting attacks."
        lang: "go"

      - id: "logging-2"
        title: "Missing Audit Trail for Deletion"
        description: "An administrator can delete user accounts with this function. What is the primary security logging issue?"
        difficulty: 1 # Intermediate
        code: |
          def delete_user(user_id, admin_user):
              user = User.query.get(user_id)
              if user:
                  # Permission checks are assumed to be handled elsewhere
                  db.session.delete(user)
                  db.session.commit()
                  return {"message": f"User {user_id} deleted by {admin_user.username}"}
              else:
                  return {"error": "User not found"}, 404
        options:
          - "The action is not logged to a persistent, secure audit trail."
          - "The function should perform a soft delete instead of a hard delete."
          - "The function does not confirm the admin's identity before deleting."
          - "The success message reveals too much information."
        correctAnswer: "The action is not logged to a persistent, secure audit trail."
        hint: "Where is the record of this critical action stored for future review?"
        explanation: "The primary issue is the lack of a persistent and secure audit trail. While the function returns a success message, it does not log this critical event to a dedicated, tamper-resistant logging system. For accountability and incident response, all sensitive actions, especially deletions by an administrator, must be logged with details like who performed the action, what was changed, and when."
        lang: "python"

  - category: "Server-Side Request Forgery"
    id: "ssrf"
    description: "SSRF flaws occur when a web application fetches a remote resource without validating the user-supplied URL."
    challenges:
      - id: "ssrf-1"
        title: "Basic SSRF Vulnerability"
        description: "This function fetches external resources based on user input. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          func fetchExternalResource(w http.ResponseWriter, r *http.Request) {
              resourceURL := r.URL.Query().Get("url")
              
              resp, err := http.Get(resourceURL)
              if err != nil {
                  http.Error(w, "Failed to fetch resource", http.StatusInternalServerError)
                  return
              }
              defer resp.Body.Close()
              
              body, err := ioutil.ReadAll(resp.Body)
              if err != nil {
                  http.Error(w, "Failed to read resource", http.StatusInternalServerError)
                  return
              }
              
              w.Write(body)
          }
        options:
          - "The function doesn't validate or sanitize the URL parameter"
          - "The function doesn't implement proper error handling"
          - "The function doesn't set a timeout for the HTTP request"
          - "The function doesn't check the response content type"
        correctAnswer: "The function doesn't validate or sanitize the URL parameter"
        hint: "What happens if the URL points to an internal network resource?"
        explanation: "The function fetches any URL provided by the user without validation, making it vulnerable to Server-Side Request Forgery (SSRF). Attackers can use this to access internal services, localhost endpoints, or cloud metadata services that should not be accessible from the internet. For example, they could access internal APIs, database endpoints, or cloud instance metadata to gather sensitive information."
        lang: "go"

      - id: "ssrf-2"
        title: "SSRF Protection Bypass via Redirect"
        description: "The application tries to prevent SSRF by performing a check to block private IP addresses. Which method could an attacker use to bypass this filter?"
        difficulty: 2 # Advanced
        code: |
          app.post('/api/process-image', (req, res) => {
              const { imageUrl } = req.body;
              
              // This function is assumed to correctly identify and block private/reserved IPs.
              if (isPrivateUrl(imageUrl)) {
                return res.status(400).send("Requests to private IPs are not allowed.");
              }
              
              const imageBuffer = await fetch(imageUrl).then(res => res.buffer());
              
              const processedImage = await sharp(imageBuffer)
                  .resize(800, 600)
                  .jpeg({ quality: 80 })
                  .toBuffer();
              
              res.set('Content-Type', 'image/jpeg');
              res.send(processedImage);
          });
        options:
          - "Use a URL that points to an attacker's server, which then redirects to the internal target."
          - "Use a DNS record that resolves to the internal IP address."
          - "Encode the internal IP address in hexadecimal or octal format."
          - "Use the `file:///` protocol to access local files instead of an HTTP URL."
        correctAnswer: "Use a URL that points to an attacker's server, which then redirects to the internal target."
        hint: "If the application's first request is to an allowed external domain, will the filter inspect where the `fetch` library gets redirected to?"
        explanation: "This is a classic SSRF filter bypass technique. Many SSRF defenses only check the initial URL provided by the user. If that URL points to a legitimate-looking external domain, the request is allowed. However, the attacker's server can respond with an HTTP redirect (e.g., 302 Found) pointing to an internal IP. The underlying HTTP client (`fetch` in this case) will often follow this redirect automatically, and this second, internal request may not be inspected by the same security filter. This allows the attacker to bypass the block on private IPs and access internal services."
        lang: "javascript"

  - category: "Cross-Site Scripting (XSS)"
    id: "xss"
    description: "XSS vulnerabilities allow attackers to inject malicious scripts into web pages viewed by other users."
    challenges:
      - id: "xss-1"
        title: "Reflected XSS"
        description: "This function displays search results to users. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          @app.route('/search')
          def search():
              query = request.args.get('q', '')
              
              return f'''
              <html>
                  <body>
                      <h1>Search Results for: {query}</h1>
                      <p>No results found for "{query}"</p>
                  </body>
              </html>
              '''
        options:
          - "The function doesn't validate the search query"
          - "The function is vulnerable to reflected XSS attacks"
          - "The function doesn't implement search functionality"
          - "The function doesn't handle empty queries"
        correctAnswer: "The function is vulnerable to reflected XSS attacks"
        hint: "What happens if the query contains HTML or JavaScript code?"
        explanation: 'The function directly interpolates user input into the HTML response without any sanitization or encoding. An attacker can inject malicious JavaScript code through the query parameter. For example, using ''q=<script>alert("XSS")</script>'' would result in the script being executed in the user''s browser, potentially stealing cookies, session tokens, or performing other malicious actions.'
        lang: "python"

      - id: "xss-2"
        title: "Stored XSS in Comments"
        description: "This system allows users to post comments that are stored and displayed. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          app.post('/api/comments', (req, res) => {
              const { content, postId } = req.body;
              
              const comment = new Comment({
                  content: content,
                  postId: postId,
                  author: req.user.id,
                  createdAt: new Date()
              });
              
              comment.save();
              res.json({ success: true, comment: comment });
          });
        options:
          - "The function doesn't validate comment length"
          - "The function is vulnerable to stored XSS attacks"
          - "The function doesn't check for spam"
          - "The function doesn't implement rate limiting"
        correctAnswer: "The function is vulnerable to stored XSS attacks"
        hint: "What happens when the comment content contains malicious HTML/JavaScript?"
        explanation: "The function stores user input directly in the database without sanitization and then displays it to other users. An attacker can post comments containing malicious HTML or JavaScript code that gets stored and then executed when other users view the comment. This stored XSS attack can persist across sessions and affect multiple users, potentially stealing credentials or performing actions on behalf of other users."
        lang: "javascript"

  - category: "Cross-Site Request Forgery (CSRF)"
    id: "csrf"
    description: "CSRF attacks force authenticated users to perform unwanted actions on a web application."
    challenges:
      - id: "csrf-1"
        title: "Missing CSRF Protection"
        description: "This endpoint allows users to change their passwords. What security protection is missing?"
        difficulty: 1 # Intermediate
        code: |
          @PostMapping("/api/change-password")
          public ResponseEntity<?> changePassword(@RequestBody PasswordChangeRequest request) {
                        User user = getCurrentUser();
              if (user.checkPassword(request.getCurrentPassword())) {
                  user.setPassword(passwordEncoder.encode(request.getNewPassword()));
                  userService.saveUser(user);
                  
                  return ResponseEntity.ok("Password changed successfully");
              } else {
                  return ResponseEntity.badRequest().body("Current password incorrect");
              }
          }
        options:
          - "The endpoint doesn't validate CSRF tokens"
          - "The endpoint doesn't check password strength"
          - "The endpoint doesn't log password changes"
          - "The endpoint doesn't implement rate limiting"
        correctAnswer: "The endpoint doesn't validate CSRF tokens"
        hint: "How would you prevent an attacker from changing a user's password via a malicious website?"
        explanation: "The endpoint lacks CSRF (Cross-Site Request Forgery) protection, making it vulnerable to attacks where malicious websites can trick authenticated users into changing their passwords. Without CSRF tokens, an attacker can create a form that automatically submits to this endpoint when a user visits their site, potentially changing the user's password without their knowledge."
        lang: "java"

  - category: "Business Logic Vulnerabilities"
    id: "business-logic"
    description: "Business logic vulnerabilities occur when application logic can be manipulated to bypass intended restrictions."
    challenges:
      - id: "business-logic-1"
        title: "Price Manipulation"
        description: "This function processes customer orders and calculates totals. What business logic vulnerability exists?"
        difficulty: 2 # Advanced
        code: |
          def process_order(order_data):
              total = order_data.get('total', 0)
              items = order_data.get('items', [])
              
              if total > 0:
                  # Process payment with client-provided total
                  payment_result = process_payment(total)
                  
                  if payment_result.success:
                      create_order(order_data)
                      return {"success": True, "order_id": generate_order_id()}
              
              return {"success": False, "error": "Invalid order"}
        options:
          - "The function trusts client-side calculations"
          - "The function doesn't validate item prices"
          - "The function is vulnerable to price manipulation"
          - "The function doesn't implement proper error handling"
        correctAnswer: "The function is vulnerable to price manipulation"
        hint: "What prevents a client from sending a manipulated total amount?"
        explanation: "The function accepts the total amount directly from the client without recalculating it based on the actual items. This allows attackers to manipulate the price by sending a lower total amount than what the items actually cost. The function should calculate the total server-side based on item prices and quantities, not trust client-provided values."
        lang: "python"

      - id: "business-logic-2"
        title: "Race Condition in Inventory"
        description: "This function handles inventory purchases and stock updates. What concurrency vulnerability exists?"
        difficulty: 2 # Advanced
        code: |
          func purchaseItem(w http.ResponseWriter, r *http.Request) {
              itemID := r.URL.Query().Get("item_id")
              quantity := r.URL.Query().Get("quantity")
              
              item := db.GetItem(itemID)
              if item.Stock < quantity {
                  http.Error(w, "Insufficient stock", http.StatusBadRequest)
                  return
              }
              
              if processPayment() {
                  item.Stock -= quantity
                  db.UpdateItem(item)
                  
                  w.Write([]byte("Purchase successful"))
              }
          }
        options:
          - "The function doesn't validate quantity"
          - "The function is vulnerable to race condition attacks"
          - "The function doesn't implement proper error handling"
          - "The function doesn't check user permissions"
        correctAnswer: "The function is vulnerable to race condition attacks"
        hint: "What happens if multiple purchases happen simultaneously for the same item?"
        lang: "go"

  - category: "API Security Vulnerabilities"
    id: "api-security"
    description: "Modern APIs often have unique security challenges related to authentication, authorization, and data validation."
    challenges:
      - id: "api-security-1"
        title: "Mass Assignment Vulnerability"
        description: "This API endpoint creates user profiles from JSON input. What security vulnerability exists?"
        difficulty: 1 # Intermediate
        code: |
          @PostMapping("/api/users")
          public ResponseEntity<User> createUser(@RequestBody User user) {
              User newUser = new User();
              newUser.setUsername(user.getUsername());
              newUser.setEmail(user.getEmail());
              newUser.setPassword(user.getPassword());
              newUser.setRole(user.getRole());
              newUser.setIsActive(user.getIsActive());
              
              User savedUser = userService.save(newUser);
              return ResponseEntity.ok(savedUser);
          }
        options:
          - "The endpoint doesn't validate email format"
          - "The endpoint is vulnerable to mass assignment attacks"
          - "The endpoint doesn't hash passwords"
          - "The endpoint doesn't check for duplicate usernames"
        correctAnswer: "The endpoint is vulnerable to mass assignment attacks"
        hint: "What happens if an attacker sends a JSON payload with unexpected fields?"
        explanation: "The endpoint is vulnerable to mass assignment attacks because it directly maps all fields from the request body to the User object without validation. An attacker can send a JSON payload with unexpected fields like 'role' or 'isActive' that could grant them elevated privileges or activate disabled accounts. The endpoint should explicitly whitelist only the fields that users are allowed to set, preventing unauthorized field manipulation."
        lang: "java"

      - id: "api-security-2"
        title: "Insecure API Key Storage"
        description: "This function saves a new API key to a configuration file. What is the primary security risk?"
        difficulty: 1 # Intermediate
        code: |
          def save_api_key(service_name, api_key):
              with open('config/api_keys.conf', 'a') as f:
                  f.write(f'{service_name.upper()}_API_KEY="{api_key}"\n')
              return True
        options:
          - "Storing API keys in a plaintext file is insecure."
          - "The function does not validate the format of the API key."
          - "The file is opened in append mode, which can be inefficient."
          - "The function should log the new key for auditing purposes."
        correctAnswer: "Storing API keys in a plaintext file is insecure."
        hint: "How are the API keys protected from unauthorized access on the filesystem?"
        explanation: "The function stores API keys in a plaintext configuration file. If an attacker gains access to the file system, they can easily read all the stored API keys. Sensitive data like API keys should be stored in a secure vault or an encrypted file, not in plaintext."
        lang: "python"

      - id: "api-security-3"
        title: "Missing API Rate Limiting"
        description: "This API endpoint processes user requests without restrictions. What security protection is missing?"
        difficulty: 1 # Intermediate
        code: |
          app.post('/api/process-data', (req, res) => {
              const { data } = req.body;
              
              const result = processUserData(data);
              
              res.json({ 
                  success: true, 
                  result: result,
                  timestamp: new Date().toISOString()
              });
          });
        options:
          - "The endpoint doesn't validate input data"
          - "The endpoint doesn't implement rate limiting"
          - "The endpoint doesn't log requests"
          - "The endpoint doesn't use authentication"
        correctAnswer: "The endpoint doesn't implement rate limiting"
        hint: "What prevents an attacker from overwhelming this endpoint with requests?"
        explanation: "The endpoint lacks rate limiting, which is a critical security protection that prevents abuse and attacks. Without rate limiting, attackers can overwhelm the endpoint with excessive requests, potentially causing denial of service, exhausting system resources, or enabling brute force attacks. Rate limiting should restrict the number of requests per user/IP address within a specific time window to maintain service availability and security."
        lang: "javascript"

  - category: "Cloud Security Misconfigurations"
    id: "cloud-security"
    description: "Cloud environments introduce new security challenges related to configuration, permissions, and service integration."
    challenges:
      - id: "cloud-security-1"
        title: "Overly Permissive IAM Policy"
        description: "An administrator has created this IAM policy for a new web application. What is the most significant potential security issue with this configuration?"
        difficulty: 1 # Intermediate
        code: |
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": "s3:*",
                "Resource": "*"
              }
            ]
          }
        options:
          - "The policy violates the principle of least privilege."
          - "The policy should specify a version date."
          - "The policy is missing a condition to restrict access by IP address."
          - "The policy should be attached to a user, not a role."
        correctAnswer: "The policy violates the principle of least privilege."
        hint: "Does the application need permission to delete buckets (`s3:DeleteBucket`) or just read objects (`s3:GetObject`)?"
        explanation: "The most significant security issue is the violation of the principle of least privilege. The policy grants all S3 actions (`s3:*`) on all resources (`*`), when the application only needs read access to a specific bucket. This means that if the application's credentials were compromised, an attacker could delete all S3 buckets in the account. The policy should be scoped down to the specific actions (e.g., `s3:GetObject`) and resources (e.g., `arn:aws:s3:::my-app-bucket/*`) required."
        lang: "json"

      - id: "cloud-security-2"
        title: "Public S3 Bucket"
        description: "This Terraform code defines an S3 bucket for storing sensitive user documents. What is the primary security risk?"
        difficulty: 1 # Intermediate
        code: |
          resource "aws_s3_bucket" "user_documents" {
            bucket = "my-app-user-documents"
            
            # This bucket is for storing private user data
            acl = "public-read"
            
            versioning {
              enabled = true
            }
          }
        options:
          - "The bucket's Access Control List (ACL) is set to 'public-read'."
          - "Server-side encryption is not enabled for the bucket."
          - "The bucket name is too predictable and could be guessed."
          - "Versioning is enabled, which increases storage costs."
        correctAnswer: "The bucket's Access Control List (ACL) is set to 'public-read'."
        hint: "What does the 'acl' property do? Who can access the files in this bucket?"
        explanation: "The primary security risk is that the bucket's Access Control List (ACL) is set to 'public-read', which makes all objects in the bucket publicly accessible to anyone on the internet. For a bucket intended to store sensitive user documents, this is a critical data exposure vulnerability. Best practice is to block all public access and use IAM policies or presigned URLs to grant access."
        lang: "hcl"

      - id: "cloud-security-3"
        title: "Server-Side Request Forgery (SSRF) via Exposed Metadata"
        description: "An application feature allows users to fetch an image from a URL. An attacker provides 'http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2-instance-role'. What is the most likely impact?"
        difficulty: 2 # Advanced
        code: |
          // The application's code allows fetching a resource from any user-provided URL.
          // For example, in Node.js:

           app.post('/fetch-image', async (req, res) => {
             const { url } = req.body;
             try {
               const response = await fetch(url);
               const data = await response.buffer();
               res.send(data);
             } catch (error) {
               res.status(500).send('Error fetching the URL');
             }
           });
        options:
          - "The attacker can retrieve temporary AWS credentials for the EC2 instance."
          - "The attacker can cause the application to make a recursive request to itself."
          - "The attacker can read arbitrary files from the server's local filesystem."
          - "The attacker can execute arbitrary commands on the EC2 instance."
        correctAnswer: "The attacker can retrieve temporary AWS credentials for the EC2 instance."
        hint: "What kind of information is available at the EC2 metadata endpoint (169.254.169.254)?"
        explanation: "This is a classic Server-Side Request Forgery (SSRF) vulnerability. The application blindly fetches a URL provided by the user. The IP address 169.254.169.254 is a special address used by cloud providers (like AWS) to expose instance metadata. By crafting a URL that points to this internal service, an attacker can trick the server into fetching and returning sensitive data, such as the temporary IAM credentials assigned to the EC2 instance. With these credentials, the attacker could potentially access other AWS services."
        lang: "javascript"

  - category: "Mobile Application Security"
    id: "mobile-security"
    description: "Mobile applications have unique security challenges related to data storage, network communication, and platform-specific vulnerabilities."
    challenges:
      - id: "mobile-security-1"
        title: "Insecure Data Storage"
        description: "This Android code saves a user's session token to SharedPreferences. What is the primary security risk?"
        difficulty: 1 # Intermediate
        code: |
          public class SessionManager {
              private static final String PREFS_NAME = "AppPrefs";
              private SharedPreferences prefs;
              
              public void saveSessionToken(String token) {
                  prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
                  SharedPreferences.Editor editor = prefs.edit();
                  editor.putString("session_token", token);
                  editor.apply();
              }
          }
        options:
          - "Data stored in SharedPreferences is not encrypted and can be read by attackers."
          - "Context.MODE_PRIVATE is not sufficient to protect the file from all threats."
          - "The session token should be stored in memory, not on disk."
          - "The function does not validate the format of the token before saving."
        correctAnswer: "Data stored in SharedPreferences is not encrypted and can be read by attackers."
        hint: "On a rooted device, can an attacker access the files stored in your app's private directory?"
        explanation: "The primary risk is that SharedPreferences stores data in a plaintext XML file in the application's private directory. On a rooted device, or if the application has a file disclosure vulnerability, an attacker can read this file and steal the session token. For sensitive data like session tokens or credentials, Android's EncryptedSharedPreferences or the Android Keystore system should be used to provide hardware-backed, encrypted storage."
        lang: "java"

      - id: "mobile-security-2"
        title: "Weak Certificate Pinning"
        description: "This iOS function attempts to validate a server's certificate to prevent man-in-the-middle attacks. Why is this implementation of certificate pinning weak?"
        difficulty: 2 # Advanced
        code: |
          class NetworkManager {
              func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
                  
                  guard let serverTrust = challenge.protectionSpace.serverTrust,
                        SecTrustGetCertificateCount(serverTrust) > 0 else {
                      completionHandler(.cancelAuthenticationChallenge, nil)
                      return
                  }
                  
                  if let serverCertificate = SecTrustGetCertificateAtIndex(serverTrust, 0) {
                      let serverCertificateData = SecCertificateCopyData(serverCertificate) as Data
                      
                      // Compare the server's certificate with the pinned certificate
                      if pinnedCertificateData == serverCertificateData {
                          completionHandler(.useCredential, URLCredential(trust: serverTrust))
                          return
                      }
                  }
                  
                  completionHandler(.cancelAuthenticationChallenge, nil)
              }
          }
        options:
          - "The function only checks the leaf certificate and ignores the rest of the chain."
          - "The function does not properly handle network errors."
          - "The pinned certificate is hardcoded, which makes it difficult to update."
          - "The function should use a third-party library for certificate pinning."
        correctAnswer: "The function only checks the leaf certificate and ignores the rest of the chain."
        hint: "An attacker could present a valid leaf certificate from a trusted CA, but with a malicious intermediate certificate. Would this code detect that?"
        explanation: "This implementation is weak because it only validates the leaf certificate (the first certificate in the chain) against the pinned certificate. It does not validate the entire certificate chain. An attacker could potentially compromise an intermediate Certificate Authority (CA) and issue a valid leaf certificate for the target domain. Because this code doesn't check the integrity of the full chain up to the root CA, it could be fooled into trusting a connection that is being intercepted by a man-in-the-middle attack. A robust implementation must validate the entire certificate chain."
        lang: "swift"

  - category: "DevOps and CI/CD Security"
    id: "devops-security"
    description: "Modern development practices introduce security challenges in build pipelines, infrastructure as code, and deployment processes."
    challenges:
      - id: "devops-security-1"
        title: "Leaking Secrets in CI/CD Logs"
        description: "This GitHub Actions workflow step attempts to deploy an application. What is the primary security risk?"
        difficulty: 1 # Intermediate
        code: |
          - name: Deploy to Server
            run: |
              echo "Deploying to production server..."
              sshpass -p "${{ secrets.PROD_SSH_PASSWORD }}" \
                scp -o StrictHostKeyChecking=no \
                app.tar.gz user@prod.server:/deployments/
        options:
          - "Passing secrets directly to command-line tools can expose them in logs."
          - "The `StrictHostKeyChecking=no` option is insecure and allows for MITM attacks."
          - "The workflow is using a password instead of an SSH key for authentication."
          - "The `sshpass` utility is not a secure way to handle passwords."
        correctAnswer: "Passing secrets directly to command-line tools can expose them in logs."
        hint: "Where do secrets appear if a process and its arguments are logged during an error or with verbose logging?"
        explanation: "The primary risk is that the secret is being passed as a command-line argument. Many CI/CD systems, including GitHub Actions, will log the commands being executed. While GitHub Actions attempts to mask secrets in logs, this is not foolproof, and secrets can be inadvertently exposed, especially in error outputs or verbose logs. The `-p` argument to `sshpass` is visible in the process list on the runner, making it vulnerable to discovery. Best practice is to use tools and methods that avoid passing secrets on the command line, such as using SSH keys with an SSH agent or built-in actions that handle secret management securely."
        lang: "yaml"

      - id: "devops-security-2"
        title: "Hardcoded Secrets in Docker Compose"
        description: "This Docker Compose file defines a multi-service application. What is the most significant security risk in this configuration?"
        difficulty: 1 # Intermediate
        code: |
          version: '3.8'
          services:
            app:
              image: myapp:latest
              ports:
                - "8080:80"
              
            database:
              image: postgres:13
              environment:
                POSTGRES_PASSWORD: "supersecretpassword123"
              volumes:
                - db-data:/var/lib/postgresql/data

          volumes:
            db-data:
        options:
          - "The database password is hardcoded in the docker-compose.yml file."
          - "The application service is exposing port 8080 to the host."
          - "The database is using the official postgres:13 image which may have vulnerabilities."
          - "The configuration is missing network policies to isolate the services."
        correctAnswer: "The database password is hardcoded in the docker-compose.yml file."
        hint: "How should secrets be managed in a Docker Compose file? What happens if this file is committed to version control?"
        explanation: "The most significant risk is hardcoding the `POSTGRES_PASSWORD` directly in the `docker-compose.yml` file. This file is often committed to version control, which would expose the database password to anyone with access to the repository. Secrets should never be hardcoded. Instead, they should be managed using Docker Secrets, environment files (`.env`) that are excluded from version control, or a dedicated secrets management tool."
        lang: "yaml"

  - category: "WebSocket Security"
    id: "websocket-security"
    description: "WebSocket connections introduce real-time communication security challenges including authentication, authorization, and message validation."
    challenges:
      - id: "websocket-security-1"
        title: "Unauthenticated WebSocket Endpoint"
        description: "This WebSocket server is set up to handle real-time chat messages. What is the most significant security risk?"
        difficulty: 1 # Intermediate
        code: |
          const WebSocket = require('ws');
          const wss = new WebSocket.Server({ noServer: true });

          httpServer.on('upgrade', (request, socket, head) => {
            // This is where authentication should happen, but it's missing.
            
            wss.handleUpgrade(request, socket, head, (ws) => {
              wss.emit('connection', ws, request);
            });
          });

          wss.on('connection', function connection(ws) {
            ws.on('message', function incoming(message) {
              // Broadcast the message to all connected clients
              wss.clients.forEach(client => {
                if (client.readyState === WebSocket.OPEN) {
                  client.send(message);
                }
              });
            });
          });
        options:
          - "The server does not authenticate or authorize clients before establishing a connection."
          - "The server does not validate or sanitize the content of incoming messages."
          - "The server is vulnerable to a denial-of-service attack from too many connections."
          - "The server broadcasts messages to all clients, which could be a privacy issue."
        correctAnswer: "The server does not authenticate or authorize clients before establishing a connection."
        hint: "What prevents an unauthorized user from connecting to the WebSocket and sending malicious messages?"
        explanation: "The most significant risk is the complete lack of authentication and authorization. Any user who can reach the server can establish a WebSocket connection and begin sending and receiving messages. In a chat application, this would allow unauthorized users to inject spam, malicious links, or abusive content. WebSocket connections should be authenticated, typically by verifying a session cookie or a token during the upgrade request, before the connection is established."
        lang: "javascript"

  - category: "GraphQL Security"
    id: "graphql-security"
    description: "GraphQL APIs have unique security challenges including query complexity, introspection, and field-level access control."
    challenges:
      - id: "graphql-security-1"
        title: "GraphQL Introspection Enabled in Production"
        description: "This GraphQL server is configured for a production environment. What is the most significant security risk in this configuration?"
        difficulty: 1 # Intermediate
        code: |
          const { ApolloServer } = require('apollo-server');

          const server = new ApolloServer({
            typeDefs,
            resolvers,
            // In a production environment, introspection should be disabled.
            introspection: true,
            playground: false // The playground is disabled, but introspection is still on.
          });
        options:
          - "Enabling introspection in production allows attackers to map out the entire API schema."
          - "The server does not have query depth limiting, allowing for denial-of-service attacks."
          - "The server is missing authentication and authorization middleware."
          - "The resolvers may contain inefficient database queries."
        correctAnswer: "Enabling introspection in production allows attackers to map out the entire API schema."
        hint: "What information can an attacker gain by querying the `__schema` field?"
        explanation: "The most significant risk is that introspection is enabled in a production environment. GraphQL's introspection system allows clients to query the server for information about the underlying API schema, including all types, fields, queries, and mutations. While useful in development, this gives an attacker a complete roadmap of the API, making it much easier to find potential vulnerabilities. Introspection should always be disabled in production."
        lang: "javascript"

  - category: "Microservices Security"
    id: "microservices-security"
    description: "Microservices architectures introduce security challenges in service-to-service communication, authentication, and data flow."
    challenges:
      - id: "microservices-security-1"
        title: "Insecure Service-to-Service Communication"
        description: "In a microservices architecture, an order service calls a user service to get customer details. What is the primary security risk in this code?"
        difficulty: 2 # Advanced
        code: |
          @Service
          public class OrderService {
              
              @Autowired
              private RestTemplate restTemplate;
              
              public User getUserDetails(String userId) {
                  // The user service endpoint is internal, but not secured
                  String url = "http://user-service/api/users/" + userId;
                  
                  ResponseEntity<User> response = restTemplate.getForEntity(url, User.class);
                  return response.getBody();
              }
          }
        options:
          - "The communication between services is not authenticated or encrypted."
          - "The `RestTemplate` is not configured with proper timeouts."
          - "The function does not validate the `userId` before making the request."
          - "The function does not properly handle potential exceptions from the API call."
        correctAnswer: "The communication between services is not authenticated or encrypted."
        hint: "What prevents another, unauthorized service on the same network from calling the user service endpoint?"
        explanation: "The primary security risk is the lack of both authentication and encryption (via TLS/HTTPS) for service-to-service communication. The request is made over plain HTTP, which means the data can be intercepted (sniffed) by other services on the network. Furthermore, there is no authentication mechanism (like client certificates or JWTs) to verify that the call is coming from a legitimate service. This could allow a compromised or malicious service on the network to make unauthorized calls to the user service and exfiltrate user data."
        lang: "java"

  - category: "Container Security"
    id: "container-security"
    description: "Containerized applications have security challenges related to image security, runtime privileges, and network isolation."
    challenges:
      - id: "container-security-1"
        title: "Container Running as Root User"
        description: "This Dockerfile is used to build a production container image for a Node.js application. What is the most significant security risk?"
        difficulty: 1 # Intermediate
        code: |
          FROM node:16-alpine

          WORKDIR /app

          COPY package*.json ./
          # It is a best practice to run as a non-root user
          RUN npm install --production

          COPY . .

          # The USER instruction is missing, so the container will run as root
          # USER node

          EXPOSE 3000

          CMD ["node", "app.js"]
        options:
          - "The container process runs as the root user by default."
          - "The `node:16-alpine` base image may contain vulnerabilities."
          - "The `EXPOSE` instruction makes the application accessible to the public."
          - "The `WORKDIR` is set to `/app`, which is a predictable location."
        correctAnswer: "The container process runs as the root user by default."
        hint: "What is the default user in a Docker container if the `USER` instruction is not specified?"
        explanation: "The most significant risk is that the Dockerfile does not specify a non-root user. By default, containers run as the root user, which means that if an attacker were to compromise the application running inside the container, they would have root privileges within that container. This could allow them to escalate their attack, for example, by exploiting a kernel vulnerability to break out of the container and gain control of the host. It is a critical security best practice to create and switch to a non-root user in your Dockerfile."
        lang: "dockerfile"

  - category: "Database Security"
    id: "database-security"
    description: "Database systems have security challenges including access control, data encryption, and query security."
    challenges:
      - id: "database-security-1"
        title: "Excessive Database Privileges"
        description: "A database administrator has created a user for a new web application. What is the most significant security flaw in this SQL script?"
        difficulty: 1 # Intermediate
        code: |
          -- Create a user for the application
          CREATE USER 'webapp'@'%' IDENTIFIED BY 'somerandompassword';

          -- Grant privileges
          GRANT ALL PRIVILEGES ON my_app_db.* TO 'webapp'@'%';

          FLUSH PRIVILEGES;
        options:
          - "The user is granted `ALL PRIVILEGES` instead of specific, required permissions."
          - "The user can connect from any host (`%`), which is too broad."
          - "The password is set in a script, which might be saved in command history."
          - "The `FLUSH PRIVILEGES` command is not always necessary."
        correctAnswer: "The user is granted `ALL PRIVILEGES` instead of specific, required permissions."
        hint: "Does the application user really need to be able to `DROP` tables or `GRANT` privileges to other users?"
        explanation: "The most significant flaw is the violation of the principle of least privilege. The user is granted `ALL PRIVILEGES` on the entire database, which gives it far more power than it likely needs. A typical web application only needs `SELECT`, `INSERT`, `UPDATE`, and `DELETE` permissions. Granting excessive privileges, such as `DROP`, `ALTER`, or `GRANT`, means that a compromise of the application (e.g., through SQL injection) could lead to the entire database being destroyed or other users' privileges being manipulated."
        lang: "sql"

  - category: "Network Security"
    id: "network-security"
    description: "Network-level security challenges include protocol vulnerabilities, traffic analysis, and network configuration issues."
    challenges:
      - id: "network-security-1"
        title: "Insecure Firewall Configuration"
        description: "A system administrator has written this script to configure the server's firewall. What is the primary security risk?"
        difficulty: 1 # Intermediate
        code: |
          #!/bin/bash
          # Flush all existing rules to start fresh
          iptables -F

          # Set default policies
          iptables -P INPUT ACCEPT
          iptables -P FORWARD DROP
          iptables -P OUTPUT ACCEPT

          # Allow established connections
          iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

          # Allow SSH on port 22
          iptables -A INPUT -p tcp --dport 22 -j ACCEPT
        options:
          - "The default policy for the INPUT chain is set to ACCEPT."
          - "The firewall does not have a rule for logging dropped packets."
          - "The FORWARD chain is set to DROP, which may block legitimate traffic."
          - "The OUTPUT chain is set to ACCEPT, which allows all outgoing traffic."
        correctAnswer: "The default policy for the INPUT chain is set to ACCEPT."
        hint: "What happens to traffic that doesn't match any of the specific `ACCEPT` rules in the INPUT chain?"
        explanation: "The primary risk is that the default policy for the INPUT chain is set to `ACCEPT`. This means that if a packet does not match any of the other rules in the chain, it will be accepted by default. This is an insecure 'default allow' posture. The secure approach is to set the default policy to `DROP` and then explicitly add `ACCEPT` rules only for the traffic that should be allowed. This 'default deny' posture ensures that any traffic not explicitly permitted is blocked."
        lang: "bash"

  - category: "Authentication Bypass"
    id: "auth-bypass"
    description: "Authentication bypass vulnerabilities allow attackers to access protected resources without proper credentials."
    challenges:
      - id: "auth-bypass-1"
        title: "Authentication Bypass via Type Juggling"
        description: "This PHP function checks if a user is an administrator. Due to a subtle language feature, it can be bypassed. What is the vulnerability?"
        difficulty: 2 # Advanced
        code: |
          function is_admin($user_id) {
            $admin_id = 0; // The admin user has an ID of 0
            
            // This comparison is vulnerable
            if ($user_id == $admin_id) {
              return true;
            }
            
            return false;
          }

          // An attacker calls the function with a specially crafted input:
          // is_admin("0-anything-else");
        options:
          - "The `==` operator performs type juggling, allowing a string to evaluate as equal to an integer."
          - "The function does not validate that the `$user_id` is of the expected type."
          - "The admin user should not have a predictable ID of 0."
          - "The function should use a framework's built-in authentication helpers."
        correctAnswer: "The `==` operator performs type juggling, allowing a string to evaluate as equal to an integer."
        hint: 'In PHP, what is the result of `"0-admin" == 0`? How does this differ from `"0-admin" === 0`?'
        explanation: "The vulnerability is a classic example of PHP type juggling. The `==` operator checks for equality after converting the types to be the same. When a string starts with a number, PHP will convert the string to that number for the comparison. So, a string like '0-admin' is converted to the integer 0, which then equals the `$admin_id` of 0, bypassing the check. Using the strict equality operator `===`, which checks both value and type without converting, would prevent this bypass."
        lang: "php"

  - category: "Data Exposure"
    id: "data-exposure"
    description: "Data exposure vulnerabilities occur when sensitive information is accidentally or intentionally disclosed."
    challenges:
      - id: "data-exposure-1"
        title: "Sensitive Data Exposure in Logs"
        description: "This logging function is intended to help with debugging. What is the primary security risk?"
        difficulty: 0 # Beginner
        code: |
          func logUserLogin(userID string, password string, userIP string) {
              // This log is written to a file that is collected by a central logging system.
              log.Printf("User login attempt: UserID=%s, Password=%s, IP=%s", 
                  userID, 
                  password, 
                  userIP)
          }
        options:
          - "The function logs the user's password in plaintext."
          - "The function logs the user's IP address, which is a privacy concern."
          - "The log message format is not structured (e.g., JSON), making it hard to parse."
          - "The function should use a more advanced logging library."
        correctAnswer: "The function logs the user's password in plaintext."
        hint: "What is the number one rule of handling passwords?"
        explanation: "The primary security risk is that the function logs the user's password in plaintext. Logs are often stored for long periods and are accessible to many people within an organization. Storing plaintext passwords in logs is a critical security vulnerability. If the log files are ever compromised, all the logged passwords will be exposed. Passwords should never be logged under any circumstances."
        lang: "go"

  - category: "Input Validation"
    id: "input-validation"
    description: "Input validation vulnerabilities occur when applications fail to properly validate and sanitize user input."
    challenges:
      - id: "input-validation-1"
        title: "DOM-based Cross-Site Scripting (XSS)"
        description: "This JavaScript code takes a URL parameter and writes it to the page. What is the primary security vulnerability?"
        difficulty: 1 # Intermediate
        code: |
          // This code runs on the client-side in a browser
          function displayWelcomeMessage() {
            const urlParams = new URLSearchParams(window.location.search);
            const username = urlParams.get('username');

            if (username) {
              const welcomeDiv = document.getElementById('welcome-message');
              // The user-provided input is directly written into the DOM
              welcomeDiv.innerHTML = 'Welcome, ' + username + '!';
            }
          }
        options:
          - "The function is vulnerable to DOM-based Cross-Site Scripting (XSS)."
          - "The `URLSearchParams` API is not supported in all browsers."
          - "The function does not handle the case where the 'username' parameter is missing."
          - "The function should validate the length of the username."
        correctAnswer: "The function is vulnerable to DOM-based Cross-Site Scripting (XSS)."
        hint: "What happens if the `username` parameter in the URL is `<img src=x onerror=alert(1)>`?"
        explanation: "The primary vulnerability is DOM-based XSS. The code takes the `username` parameter from the URL and writes it directly to the DOM using `innerHTML`. An attacker can craft a URL with a malicious payload in the `username` parameter. When a victim clicks this link, the malicious script will be inserted into the page and executed in the context of the user's browser. To prevent this, user input should be treated as text, not HTML, for example by using `textContent` instead of `innerHTML`."
        lang: "javascript"

  - category: "Privilege Escalation"
    id: "privilege-escalation"
    description: "Privilege escalation vulnerabilities allow attackers to gain higher levels of access than intended."
    challenges:
      - id: "privilege-escalation-1"
        title: "Privilege Escalation via Mass Assignment"
        description: "This API endpoint allows a user to update their profile information. How could an attacker exploit this to gain administrative privileges?"
        difficulty: 2 # Advanced
        code: |
          @PutMapping("/api/users/me")
          public ResponseEntity<User> updateMyProfile(@RequestBody User updatedUserData) {
              User currentUser = getCurrentUser();
              
              // This is vulnerable to mass assignment
              currentUser.setUsername(updatedUserData.getUsername());
              currentUser.setEmail(updatedUserData.getEmail());
              // An attacker can also set the role!
              currentUser.setRole(updatedUserData.getRole());
              
              userService.save(currentUser);
              return ResponseEntity.ok(currentUser);
          }
        options:
          - "By passing a `role` field with the value 'ADMIN' in the JSON payload."
          - "By using a SQL injection attack to modify the roles table."
          - "By brute-forcing the session token of an administrator."
          - "By performing a cross-site scripting (XSS) attack on the profile page."
        correctAnswer: "By passing a `role` field with the value 'ADMIN' in the JSON payload."
        hint: "The application directly maps the incoming JSON to the user object. What happens if an attacker adds a field that shouldn't be user-modifiable?"
        explanation: 'This is a mass assignment vulnerability. The endpoint allows users to update their profile by accepting a JSON object that is directly mapped to the User entity. Because the `role` property is not excluded from the update logic, an attacker can add `"role": "ADMIN"` to their request and escalate their privileges. The fix is to use a specific Data Transfer Object (DTO) for the update that only includes fields the user is allowed to change (e.g., username and email), or to explicitly ignore the `role` field from the incoming request.'
        lang: "java"
